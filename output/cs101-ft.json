{
  "num_weeks": 2,
  "num_chapters_per_week": 5,
  "num_practice_sessions": 0,
  "weeks": {
    "3": {
      "week_num": 3,
      "learning_goal": "Professional Code Foundations: In this unit, students will learn to write clean, readable, and well-documented code, refactor long scripts into modular, reusable functions, and strengthen program reliability through debugging, input validation, edge-case testing, and safe refactoring supported by tests.",
      "chapters": [
        {
          "chapter_num": 1,
          "title": "Writing Clear and Readable Code",
          "learning_goals": "Learn how to make code easy to understand by using meaningful names, purposeful docstrings and comments, and consistent formatting. Practice these skills in small, real-world scripts so you can confidently write and share clean, readable Python programs.",
          "lessons": [
            {
              "title": "Opening session and Q&A",
              "learning_outcomes": "Ask questions, clarify concepts, and engage with instructors and peers in real-time.",
              "time_minutes": 60,
              "type": "Group Class"
            },
            {
              "title": "Welcome to CS101!",
              "learning_outcomes": "Understand the course structure and main topics",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Naming that tells a story",
              "learning_outcomes": "Rename variables and functions to improve clarity",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Crafting docstrings that explain the why",
              "learning_outcomes": "Write docstrings that explain the purpose and usage of functions",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Writing comments with real purpose",
              "learning_outcomes": "Add comments that clarify reasoning instead of obvious behavior",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Keeping it clean",
              "learning_outcomes": "Apply consistent formatting for whitespace, indentation, and line breaks",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Practice Lesson: Cafe order tracker",
              "learning_outcomes": "Practice renaming variables and functions to tell a clear story, adding meaningful docstrings and comments, and applying consistent formatting in a small script. Output: A console-based cafe order tracker that records drink orders and prints a simple order summary.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Playlist manager",
              "learning_outcomes": "Apply naming conventions, docstrings, and purposeful comments to transform a messy music playlist script into clean, readable code. Output: A script that lets a user add, remove, and list songs in a playlist in the console.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Recipe steps formatter",
              "learning_outcomes": "Use whitespace, indentation, and line breaks to format a recipe-processing script so that its structure and intent are immediately clear. Output: A script that takes a list of recipe steps and prints them in a neatly numbered, consistently formatted way.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: To-do list annotator",
              "learning_outcomes": "Combine clear naming, docstrings, and reasoning-focused comments to document a small to-do list utility as if handing it to another developer. Output: A script that manages a to-do list (add, mark done, show) with thoroughly documented functions and clean layout.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Closing session",
              "learning_outcomes": "Wrap up the day togeher with your peers and ask final questions",
              "time_minutes": 30,
              "type": "Group Class"
            }
          ]
        },
        {
          "chapter_num": 2,
          "title": "Writing Clear, Reliable Python Programs",
          "learning_goals": "Learn to refactor messy scripts into small, readable, and reusable functions while using print tracing and invariants to follow program flow and catch bugs early. Through targeted practice projects, you’ll build habits that make your code easier to understand, maintain, and safely extend.",
          "lessons": [
            {
              "title": "Opening session and Q&A",
              "learning_outcomes": "Ask questions, clarify concepts, and engage with instructors and peers in real-time.",
              "time_minutes": 60,
              "type": "Group Class"
            },
            {
              "title": "Making code instantly readable",
              "learning_outcomes": "Rewrite code to pass a readability checklist",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Turning long scripts into sharp functions",
              "learning_outcomes": "Understand why long monolithic scripts reduce readability, reusability, and maintainability; Split a long script into focused functions with well-defined signatures",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Following program flow with print tracing",
              "learning_outcomes": "Insert print-based tracing statements to follow program execution",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Using invariants as safety checkpoints",
              "learning_outcomes": "Understand how invariants help ensure program correctness and prevent bugs; Apply invariants to check assumptions at key points in the code",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Designing functions that can be reused anywhere",
              "learning_outcomes": "Use parameters and return values to ensure modular function design",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Practice Lesson: Expense splitter",
              "learning_outcomes": "Refactor a long, monolithic “split the bill” script into small, readable functions that use parameters, return values, and follow a readability checklist. Output: A script that calculates how much each friend should pay for a shared restaurant bill and prints a clear breakdown.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Number analyzer",
              "learning_outcomes": "Extract focused functions from a single long script that analyzes numbers, and insert print-based tracing to follow program flow step by step. Output: A script that reads a list of numbers, calculates stats (min, max, average), and prints trace messages showing each processing step.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Password strength helper",
              "learning_outcomes": "Design reusable functions with clear signatures and invariants that check assumptions at key points while analyzing password strength. Output: A script that rates password strength and prints explanations, using internal invariant checks to guard against invalid states.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Text report generator",
              "learning_outcomes": "Turn a cluttered reporting script into modular, reusable functions while using print tracing and invariants to verify correct flow and data at each stage. Output: A script that takes some sample text data and prints a simple, well-structured report (counts, summaries) to the console.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Closing session",
              "learning_outcomes": "Wrap up the day togeher with your peers and ask final questions",
              "time_minutes": 30,
              "type": "Group Class"
            }
          ]
        },
        {
          "chapter_num": 3,
          "title": "Robust Programs Through Testing and Validation",
          "learning_goals": "Learn to systematically debug code, design edge-case and boundary tests, and implement solid input validation with clear error handling so programs behave predictably and fail gracefully in real-world scenarios.",
          "lessons": [
            {
              "title": "Opening session and Q&A",
              "learning_outcomes": "Ask questions, clarify concepts, and engage with instructors and peers in real-time.",
              "time_minutes": 60,
              "type": "Group Class"
            },
            {
              "title": "Debugging step by step",
              "learning_outcomes": "Apply a debugging checklist to isolate and resolve defects",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Stress it to the edge",
              "learning_outcomes": "Include edge cases and invalid inputs in test coverage",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Pushing the limits",
              "learning_outcomes": "Understand how clear input and output boundaries ensure reliable, predictable program behavior; Design and implement tests that verify code correctness at boundary and edge conditions",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Validating inputs before they break things",
              "learning_outcomes": "Implement input validation to prevent unexpected behavior",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "The art of a well-placed error",
              "learning_outcomes": "Write clear error messages and handle invalid inputs gracefully",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Practice Lesson: Temperature converter debugger",
              "learning_outcomes": "Use a debugging checklist and step-by-step reasoning to find and fix bugs in a temperature conversion script. Output: A script that reliably converts between Celsius and Fahrenheit, including tests that confirm correct behavior.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Login form validator",
              "learning_outcomes": "Implement input validation and clear error messages for a simple login-style form, including tests for invalid and edge-case inputs. Output: A script that asks for username and password, validates them against simple rules, and prints helpful error or success messages.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Shopping cart edge cases",
              "learning_outcomes": "Design and run tests that stress a shopping cart calculator with edge and boundary conditions, ensuring predictable behavior for tricky inputs. Output: A script that totals cart items, applies discounts and taxes, and includes a small test suite that prints pass/fail results for edge cases.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Quiz input guardian",
              "learning_outcomes": "Combine input validation, boundary checks, and well-placed error messages to make a small quiz program robust against bad user input. Output: A script that runs a short quiz, safely handles invalid answers (like empty or out-of-range choices), and reports the final score.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Closing session",
              "learning_outcomes": "Wrap up the day togeher with your peers and ask final questions",
              "time_minutes": 30,
              "type": "Group Class"
            }
          ]
        },
        {
          "chapter_num": 4,
          "title": "Refactoring and Professional Coding Practice",
          "learning_goals": "Strengthen your ability to safely refactor code, validate behavior with tests, and apply professional coding practices such as clear naming, modular design, and basic planning before coding. Learn to balance upfront design with iterative implementation while reviewing your own work to identify strengths and areas for improvement.",
          "lessons": [
            {
              "title": "Opening session and Q&A",
              "learning_outcomes": "Ask questions, clarify concepts, and engage with instructors and peers in real-time.",
              "time_minutes": 60,
              "type": "Group Class"
            },
            {
              "title": "Refactoring with confidence",
              "learning_outcomes": "Perform safe refactoring moves such as renaming, extracting functions, and removing dead code",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Making sure nothing breaks",
              "learning_outcomes": "Re-run tests to confirm consistent behavior after refactoring",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Weekly review: professional coding practices",
              "learning_outcomes": "Review and consolidate key professional coding practices covered in the week; Identify personal strengths and areas for improvement in coding style and reliability",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Balancing planning and coding",
              "learning_outcomes": "Explain trade-offs between planning and immediate coding",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Practice Lesson: To-do list refactor – Part 1",
              "learning_outcomes": "Perform safe refactoring moves (renaming, extracting functions, removing dead code) on a previously written to-do list script without changing its behavior. Output: A cleaner, more modular to-do list script that still supports adding, listing, and completing tasks.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: To-do list refactor – Part 2",
              "learning_outcomes": "Re-run and extend tests after refactoring the to-do list to confirm behavior is unchanged and to catch any regressions. Output: A refactored to-do list script plus a small automated or scripted test runner that prints which behaviors still work correctly.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Habit tracker review",
              "learning_outcomes": "Review and apply professional coding practices—naming, documentation, modularity, validation, and testing—to a small habit-tracking script and identify personal improvement areas. Output: A habit tracker script (add habits, mark done, view status) with an accompanying self-review note listing strengths and weaknesses.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Note organizer planner",
              "learning_outcomes": "Practice balancing planning and coding by sketching a simple note organizer’s design (functions, data flow, error handling) before writing the implementation. Output: A console-based note organizer script that follows a brief written plan describing its structure and responsibilities.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Refactor and verify calculator",
              "learning_outcomes": "Safely refactor a basic calculator script, apply planning, then use tests to ensure nothing breaks while improving clarity and reliability. Output: A refactored calculator script (add, subtract, multiply, divide) with a small set of test cases that confirm correct results and error handling.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Closing session",
              "learning_outcomes": "Wrap up the day togeher with your peers and ask final questions",
              "time_minutes": 30,
              "type": "Group Class"
            }
          ]
        },
        {
          "chapter_num": 5,
          "title": "Weekly Review",
          "learning_goals": "Review key concepts learned during the week and complete the weekly assessment.",
          "lessons": [
            {
              "title": "Weekly Review Prep Session",
              "learning_outcomes": "We'll review key concepts and prepare for the assessment",
              "time_minutes": 90,
              "type": "Lesson"
            },
            {
              "title": "Prep Lesson",
              "learning_outcomes": "Prep lesson for the weekly review",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Weekly Review Assessment",
              "learning_outcomes": "Our weekly assessment, where you will test your knowledge from the last week using practical questions and challenges",
              "time_minutes": 240,
              "type": "Assessment"
            }
          ]
        }
      ]
    },
    "4": {
      "week_num": 4,
      "learning_goal": "From Ideas to Apps: In this unit, students will learn to break down problems into subproblems, plan solutions with pseudocode and test tables, then incrementally translate those plans into well-structured Python scripts using common patterns (like dictionary lookups and helper functions), while documenting their work with clear comments, feature briefs, and problem statements.",
      "chapters": [
        {
          "chapter_num": 1,
          "title": "From Plan to Python",
          "learning_goals": "In this chapter, students will learn to turn clear pseudocode plans into working Python programs using common solution patterns like dictionary lookups and structured function stubs. They will practice keeping code aligned with their original plans through comments, iteratively refining logic, and building small, real-world scripts from start to finish.",
          "lessons": [
            {
              "title": "Opening session and Q&A",
              "learning_outcomes": "Ask questions, clarify concepts, and engage with instructors and peers in real-time.",
              "time_minutes": 60,
              "type": "Group Class"
            },
            {
              "title": "Understanding common solution patterns",
              "learning_outcomes": "Recognize and implement common patterns like dictionary lookups",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Reviewing the plan",
              "learning_outcomes": "Identify logical gaps or overlaps in pseudocode",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "From plan to working machine",
              "learning_outcomes": "Translate pseudocode into working Python code step by step",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Keeping comments that connect to pseudocode",
              "learning_outcomes": "Maintain comments that connect code to pseudocode blocks",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Creating function stubs for structure",
              "learning_outcomes": "Write function stubs that define intended structure",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Practice Lesson: Café menu helper",
              "learning_outcomes": "Use dictionary lookup patterns and comments tied to pseudocode to build a simple menu price finder. Output: A script that asks for a drink name and prints its price using a dictionary-based menu.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Music genre recommender",
              "learning_outcomes": "Translate a pseudocode plan into Python with function stubs and dictionary-based mappings for simple recommendations. Output: A script that takes a mood as input and prints a recommended music genre and example artist.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Library late fee calculator",
              "learning_outcomes": "Review and refine pseudocode for logical gaps, then implement it step by step into Python with comments that mirror the plan. Output: A script that asks for days overdue and membership type and prints the calculated late fee.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Travel budget planner",
              "learning_outcomes": "Create clear function stubs from a pseudocode plan and incrementally fill them in while keeping comments aligned with the original structure. Output: A script that estimates total trip cost based on destination, days, and daily budget using multiple helper functions.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Closing session",
              "learning_outcomes": "Wrap up the day togeher with your peers and ask final questions",
              "time_minutes": 30,
              "type": "Group Class"
            }
          ]
        },
        {
          "chapter_num": 2,
          "title": "Building and Testing Simple Apps",
          "learning_goals": "Learn to incrementally develop small applications by starting with stubs, designing input-output test tables, dry running pseudocode, and then integrating validated input, core logic, and formatted output. Practice these skills through hands-on mini-projects (to-do list, movie filter, password checker) and demonstrate working apps with multiple test cases.",
          "lessons": [
            {
              "title": "Opening session and Q&A",
              "learning_outcomes": "Ask questions, clarify concepts, and engage with instructors and peers in real-time.",
              "time_minutes": 60,
              "type": "Group Class"
            },
            {
              "title": "Building code incrementally",
              "learning_outcomes": "Use hardcoded return values as placeholders; Replace stubs with working implementations incrementally",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Creating test tables for pseudocode plans",
              "learning_outcomes": "Build input-output test tables for pseudocode plans",
              "time_minutes": 30,
              "type": "Assessment"
            },
            {
              "title": "Dry running plans with test values",
              "learning_outcomes": "Perform dry runs using pseudocode test-table values",
              "time_minutes": 30,
              "type": "Assessment"
            },
            {
              "title": "Integrating logic into a full app",
              "learning_outcomes": "Integrate validated inputs, logic, and output formatting into one app",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Demonstrating the working app",
              "learning_outcomes": "Demonstrate working apps with multiple test cases",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Practice Lesson: To-do list tester - Part 1",
              "learning_outcomes": "Build and use a test table and hardcoded return values to incrementally develop a to-do list feature. Output: A script with stubbed functions for adding and listing tasks that return hardcoded data and are verified against a test table.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: To-do list tester - Part 2",
              "learning_outcomes": "Replace stubs with working logic, dry run with test values, and integrate validated input and formatted output into the to-do list. Output: A script that lets a user add tasks, mark them as done, and display them in a readable format.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Movie rating filter",
              "learning_outcomes": "Create input-output test tables and dry run pseudocode to incrementally implement a simple movie filter app. Output: A script that filters a small movie list by minimum rating and prints the matching titles.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Password strength checker",
              "learning_outcomes": "Integrate validated input, incremental logic, and formatted feedback, then demonstrate the app with multiple test cases. Output: A script that evaluates password strength based on length and character types and prints a strength label and hints.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Closing session",
              "learning_outcomes": "Wrap up the day togeher with your peers and ask final questions",
              "time_minutes": 30,
              "type": "Group Class"
            }
          ]
        },
        {
          "chapter_num": 3,
          "title": "From Ideas to Clear Feature Specs",
          "learning_goals": "Learn to turn vague ideas into clear, structured feature descriptions and Python problem statements by separating user-focused purpose from technical details, defining success criteria, and specifying example inputs and outputs (including edge cases).",
          "lessons": [
            {
              "title": "Opening session and Q&A",
              "learning_outcomes": "Ask questions, clarify concepts, and engage with instructors and peers in real-time.",
              "time_minutes": 60,
              "type": "Group Class"
            },
            {
              "title": "Weekly review: from ideas to instructions",
              "learning_outcomes": "Summarize the process of moving from ideas to pseudocode to working code; Reflect on challenges and improvements in planning and implementation",
              "time_minutes": 240,
              "type": "Lesson"
            },
            {
              "title": "Writing a clear feature brief",
              "learning_outcomes": "Write a concise paragraph defining feature goals, target users, and context",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Separating purpose from technical details",
              "learning_outcomes": "Differentiate purpose from technical implementation details",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Writing a structured problem statement",
              "learning_outcomes": "Create structured Python problem statements with success criteria",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Defining example inputs and outputs",
              "learning_outcomes": "Provide example inputs and outputs for normal and edge cases",
              "time_minutes": 30,
              "type": "Assessment"
            },
            {
              "title": "Practice Lesson: Recipe finder brief",
              "learning_outcomes": "Write a clear feature brief and structured problem statement that separate purpose from technical details for a recipe finder feature. Output: A written brief and problem statement describing a recipe finder tool with success criteria.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Study planner feature brief",
              "learning_outcomes": "Define a feature’s goals, users, and context, then provide example inputs and outputs including edge cases. Output: A written description of a study planner feature plus a small table of normal and edge-case input-output examples.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Expense tracker problem statement",
              "learning_outcomes": "Summarize the idea-to-code journey and write a structured Python problem statement with explicit success criteria and example scenarios. Output: A document that states the expense tracker problem, success criteria, and example user interactions.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Music playlist organizer",
              "learning_outcomes": "Differentiate user-focused purpose from implementation details while defining example inputs and outputs for a playlist organizer. Output: A short design write-up describing the playlist organizer’s purpose plus example commands and expected results.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Closing session",
              "learning_outcomes": "Wrap up the day togeher with your peers and ask final questions",
              "time_minutes": 30,
              "type": "Group Class"
            }
          ]
        },
        {
          "chapter_num": 4,
          "title": "Problem Decomposition & Planning",
          "learning_goals": "Learn to break larger programming tasks into clear subproblems, define inputs and outputs for each, and arrange them into a logical sequence. Practice mapping these subproblems to common coding patterns while planning real-world mini-projects like shopping carts, quiz apps, workout trackers, and weather scripts.",
          "lessons": [
            {
              "title": "Opening session and Q&A",
              "learning_outcomes": "Ask questions, clarify concepts, and engage with instructors and peers in real-time.",
              "time_minutes": 60,
              "type": "Group Class"
            },
            {
              "title": "Breaking down into subproblems",
              "learning_outcomes": "Decompose problems into subproblems",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Defining subproblem inputs and outputs",
              "learning_outcomes": "Define clear inputs and outputs for subproblems",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Sequencing subproblems logically",
              "learning_outcomes": "Arrange and implement subproblems in logical sequence",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Matching subproblems to patterns",
              "learning_outcomes": "Apply common coding patterns to subproblems",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Practice Lesson: Shopping cart breakdown - Part 1",
              "learning_outcomes": "Decompose a shopping cart calculator into subproblems and define clear inputs and outputs for each subproblem. Output: A written breakdown listing subproblems (like adding items, computing totals, applying discounts) with their inputs and outputs.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Shopping cart breakdown - Part 2",
              "learning_outcomes": "Sequence the shopping cart subproblems logically and map each one to common coding patterns such as loops and dictionary lookups. Output: A structured plan showing the ordered steps and chosen patterns for each shopping cart subproblem.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Quiz app planner",
              "learning_outcomes": "Break a quiz app into subproblems and match each to suitable coding patterns while defining how data will flow between them. Output: A subproblem map describing question storage, scoring, and feedback with associated patterns and data flow.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Workout tracker planner",
              "learning_outcomes": "Define subproblem inputs and outputs and arrange them into a logical sequence for a workout tracking tool. Output: A step-by-step workflow document that shows how workout data is entered, processed, and summarized.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Practice Lesson: Weather summary script",
              "learning_outcomes": "Apply subproblem decomposition and pattern matching to plan a small script that summarizes weather readings. Output: A pseudocode-style plan listing subproblems (parsing data, computing averages, formatting output) and the patterns used for each.",
              "time_minutes": 30,
              "type": "Exercise"
            },
            {
              "title": "Closing session",
              "learning_outcomes": "Wrap up the day togeher with your peers and ask final questions",
              "time_minutes": 30,
              "type": "Group Class"
            }
          ]
        },
        {
          "chapter_num": 5,
          "title": "Weekly Review",
          "learning_goals": "Review key concepts learned during the week and complete the weekly assessment.",
          "lessons": [
            {
              "title": "Weekly Review Prep Session",
              "learning_outcomes": "We'll review key concepts and prepare for the assessment",
              "time_minutes": 90,
              "type": "Lesson"
            },
            {
              "title": "Prep Lesson",
              "learning_outcomes": "Prep lesson for the weekly review",
              "time_minutes": 30,
              "type": "Lesson"
            },
            {
              "title": "Weekly Review Assessment",
              "learning_outcomes": "Our weekly assessment, where you will test your knowledge from the last week using practical questions and challenges",
              "time_minutes": 240,
              "type": "Assessment"
            }
          ]
        }
      ]
    }
  }
}