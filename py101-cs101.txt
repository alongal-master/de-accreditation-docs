### Writing your first program
Introduce the Maestro Code Editor; Write and execute a simple Python script using the print() function

### Unlocking print() power-ups
Print multiple values using commas; Understand that printing is always in a new line; Print multiple text and numeric values using the + and * operators; Predict the output of a script that uses multiple print() statements

### Creating art with code
Decide on a simple visual pattern you can create using prints, and challenge the student to create it; Define what ASCII is and explain how ASCII characters can be used to create images and patterns; Generate a multi-line ASCII art pattern using any print method

### Introduction to variables
Explain that a variable is a named placeholder for a value in memory; Write a valid variable name following Python conventions; Assign a value (e.g., a number or a piece of text) to a variable using the = operator; Use the print() function to display the value stored in a variable

### Working with text
Define a "data type" as a category of data that determines what you can do with it; Create a string variable by enclosing text in single (') or double (") quotes; Combine two strings using the + operator (concatenation); Predict the output when printing string variables

### Working with numbers
Distinguish between an integer (int, a whole number) and a float (float, a number with a decimal); Create variables to store integer and float values; Perform basic arithmetic operations (+, -, *, /) on numeric variables; Explain why 5 is different from "5"

### Checking the facts
Use the type() function to check the data type of a variable's value; Correctly identify str, int, and float types in the output of the type() function; Explain the purpose of the type() function as a way to understand your data

### Understanding type errors and f-strings
Identify and explain a TypeError that occurs when attempting to combine incompatible data types (e.g., print("Age: " + 25)); Embed variables of any type directly inside a string using f-string syntax (f"..."); Combine text and variables to produce a clean, readable, and dynamic output

### Type casting
Use the str(), int(), and float() functions to convert values between data types; Predict the outcome of valid type conversions (e.g., int("123")); Identify cases where a conversion will fail and result in a ValueError (e.g., int("hello"))

### Create your personal profile
Define and use variables of str, int, and float types to represent personal data (e.g., name, age, hourly_rate); Use the type() function to verify the data types of the created variables; Use f-strings to combine all the variables into a multi-line, well-formatted "profile card" output; Write a short, commented script that is readable and error-free

### Create the bot's logo
Articulate the overall goal of the project: to build a multi-part, text-based bot; Design a simple but unique visual pattern using multiple print() statements; Combine strings and special characters to create a multi-line ASCII art logo; Write clean, readable code for the visual component of the final script

### Give the bot a skill
Use variables to store and manipulate numerical data; Perform a multi-step arithmetic calculation using the variables you created; Use an f-string to embed the results of the calculation into a clean, human-readable sentence

### Assemble your bot
Synthesize code from previous lessons into a single, sequential Python script; Add comments (#) to explain the different sections of the program (logo, introduction, calculation); Execute a complete, multi-part program that runs without errors from top to bottom


### Expressions and operator precedence

- Control the order of expression evaluation in Python through operator precedence and parentheses.

### Updating values and printing expressions

- Update numeric variables with compound assignment (+=, -=) and predict final values.
- Print expressions that mix numbers and text (via commas) and explain the output behavior.

### Modeling real-world calculations

- Translate a two-step word problem into an arithmetic expression and compute the result.
- Do arithmetic directly inside print() to produce clear, useful outputs.
- Compare two equivalent formulations and choose the clearer one.

### Division modes: / vs // with quotient and remainder

- Compute and contrast true division (/) and floor division (//) on integers; explain the difference.
- Use // and % together to derive quotient and remainder for practical cases (e.g., packing/scheduling).

###  Modulo in practice: parity, cycles, positions

- Use x % 2 to detect parity and explain why it works.
- Apply modulo to cyclic positions (e.g., every Nth item, rotating shifts) to simplify branching.

### Rounding, and money format

- Use round(x, n) to control numeric precision.
- Format prices with f"{x:.2f}" as a quick money-format (value vs representation).

###  Talking to your program: getting input from users

- Explain why programs interact with users and when input() is appropriate; collect input with clear prompts.
- Convert numeric inputs to the correct type before computing and print a friendly summary.

###  Functions i: why, define, and call

- Understand how functions reduce repetition and improve reuse.
- Understand the structure of Python functions.
- Define a function with one or two parameters and call it with literals and variables.

###  Functions ii: Inside the function

- Understand the structure of a function, including its name, parameters, indentation, and return value.
- Call functions with arguments correctly and trace how values are passed from the call site to parameters, verifying the flow using print statements.

###  Functions iii: return vs print and early return

- Differentiate printing vs returning values.
- Use return to pass results and apply early returns.

###  Scope and local variables

- Understand that variables created inside a function exist only within that function’s scope (local).
- Explain how local and global scopes differ and identify when each is used.
- Demonstrate how data can be passed into functions through parameters instead of relying on global variables.

### Python errors: meet the traceback

- Identify key parts of a traceback, including the error type, and a short explanation of what went wrong.

###  Introduction to debugging

- Define debugging as the process of finding and fixing errors in a program.
- Use print statements to observe variable values and trace the program’s flow step by step.
- Insert and remove targeted print statements to test assumptions and confirm how the code behaves.

###  Weekly review: Café receipt
Create a program that acts as a mini receipt calculator. 


###  Control flow overview: decisions vs repetition

- Identify when a task requires selection (if/else) versus repetition (loop) and provide an example of each.
- Write a 3–5 line text-only flow outline in comments and map each line to if/else or loop constructs.

###  If/else: syntax, indentation, mental model

- Introduce indentation as Python’s rule for defining code blocks.
- Write a basic if/else using comparison operators (==, !=, <, >, <=, >=).
- Differentiate assignment (=) from equality (==) in conditions.

###  Logical operators: and/or/not and short-circuiting

- Combine comparisons with and, or, not to form compound conditions.
- Show short-circuit behavior by adding prints to the right-hand side expression.

###  Booleans and comparisons: equality vs identity

- Use True/False in expressions and store boolean results in variables.
- Differentiate between '==' (value equality) and 'is' (identity equality).

###  String membership with 'in' in conditions

- Test substring membership with 'in' and negate with 'not in'.
- Use membership checks inside if/elif branches to drive simple decisions.

###  Elif and refactoring nested decisions

- Refactor a nested if/else into an equivalent if/elif/else chain.
- Order conditions to avoid overlaps and unreachable branches.

###  Decision tables to branching logic

- Translate a 3–5 row decision table into clear if/elif/else code.
- Verify mutual exclusivity and completeness of the conditions.

###  For loops and range(): counting iterations

- Write for loops with range(stop), range(start, stop), range(start, stop, step).
- Accumulate a total across iterations and print the result.
- Generate even/odd sequences and countdowns with range.

###  Meet the while loop

- Understand what a while loop is and when it is more suitable than for.
- Understand the risk of infinite loops and explain how to prevent them.
- Write a while loop to repeat actions until a condition changes.

###  Loop control: break and continue

- Understand when to exit a loop early with break versus letting it complete naturally.
- Insert break to exit early on a condition and continue to skip an iteration.

###  Counters and totals

- Initialize and update a counter and running total correctly inside a loop.
- Print the final counts and totals after the loop completes.

###  Weekly Review: Score trackerScore tracker
You need to build a score tracker program. The program should prompt the user to enter the names of two teams and set a maximum score that determines when the game ends.  After that, the program should repeatedly ask the user to enter the updated scores for each team.


###  String skills upgrade i: indexing and slicing

- Access individual characters in a string using 0-based indexing.
- Use slice notation [start:stop] and [start:stop:step] to extract substrings.
- Use negative indices to access characters from the end of a string.

###  String skills upgrade ii: common methods

- Use strip, lower, replace, and find to clean and search text.

###  String skills upgrade iii: splitting and joining text

- Split delimited lines into fields and re-join using a chosen delimiter.
- Handle extra whitespace and empty fields during splitting.

###  Lists i: creating lists

- Create lists with literals and from range(); print length with len().
- Explain that lists are mutable and show a visible effect of mutation.
- Understand when a list is a better choice than separate variables.

###  Lists ii: indexing and slicing

- Access list elements by index and understand how indexing works.
- Modify list elements and create sublists using slicing.
- Handle out-of-range errors (IndexError) in list access.

### Lists iii: mastering list iteration

- Use a for loop with range() and len() to iterate over indices and access list elements by their position.
- Use a for loop to iterate directly over the values in a list and perform actions on each element.

###  Lists iv: common methods

- Modify a list in place with append, insert, remove, pop, and extend.

###  Ordering lists: sorted() vs .sort()

- Sort a list in place with .sort() and create a sorted copy with sorted().
- Use .sorted() parameters ('key' and 'reverse') to customize ordering and explain stability.

###  Dictionaries i: keys and values

- Create dictionaries and access values by key; add and update key–value pairs.
- Explain valid key types and why mutability matters for keys.

###  Dictionaries ii: iteration patterns

- Iterate over a dictionary’s keys, values, and key–value pairs.
- Select the most suitable iteration pattern (keys, values, or items) based on the task’s goal.

###  Updates and copy semantics

- Show the difference between assignment (aliasing) and shallow copy for lists and dicts.
- Explain that list slicing (x[:]) creates a new list independent of the original.
- Use list(x) / x.copy() / dict(x) appropriately to avoid unintended aliasing.

###  Nested structures and safe mutation

- Access and modify data inside nested lists and dictionaries step by step.
- Use safe methods like get() to read values.

###  Parsing text to list of dicts: tokenize and map fields

- Map split fields into a dict with named keys for a single line.
- Extend the approach to multiple lines to build a list of dicts.

###  Weekly Review: Personal music manager
Build a program that helps a user manage their music playlist. Students will create a list of song dictionaries (title, artist, duration, genre), add and remove songs, sort the playlist by different fields, and display summaries like total songs by genre or average duration.



### Naming that tell a story
    - Demonstrate the ability to rename variables and functions to improve clarity.
### Crafting docstrings that explain the why
    - Add clear docstrings that explain the purpose and usage of functions.
### Writing comments with real purpose
    - Add purposeful comments that explain reasoning, not obvious code behavior.
### Keeping it clean
    - Apply consistent formatting rules for whitespace, indentation, and line breaks.
### Making code instantly readable
     - Rewrite code to pass a readability checklist you define.
### Turning long scripts into sharp functions
    - Split a long script into focused functions with well-defined signatures.
### Following program flow with print tracing
    - Insert print-based tracing statements to follow program flow.
### Using invariants as safety checkpoints
    - Apply invariants to check assumptions at key points in the code.
### Designing functions that can be reused anywhere
    - Use parameters and return values to ensure modular, reusable design.
### 10. Debugging step by step
    - Use a minimal debugging checklist to isolate a defect in a provided snippet.
### 11. Stress it to the edge
    - Include edge cases and invalid inputs in tests.
### 12. Pushing the limits
    - Define and test clear input and output boundaries, ensuring the code behaves correctly at limits and under invalid conditions.
### 13. Validating inputs before they break things
    - Add input validation to a function to prevent unexpected behavior.
###  The art of a well-placed error
    - Write clear error messages and handle invalid inputs gracefully.
### Refactoring with confidence
    - Perform safe refactoring moves such as renaming, extracting functions, and removing dead code.
### Making sure nothing breaks
    - Re-run tests to confirm behavior remains consistent after refactoring.
### Weekly Review:  Grandma’s secret recipe
Grandma wrote a script to calculate ingredient quantities for her famous cookie recipe, but it is a mess. Students refactor her kitchen code by splitting it into neat functions, adding docstrings that “tell the story” of the recipe steps, and validating edge cases (like zero or negative servings). They write tests to ensure the recipe always scales correctly.



### Balancing planning and coding
        - Understand the trade-offs between planning and coding immediately and how upfront planning improves clarity and reduces rework.
### Breaking the problem
        - Break down a problem into precise, ordered pseudocode steps.
### Hierarchy in pseudocode
        - Understand pseudocode concepts and apply numbering and indentation to clearly represent sequence and hierarchical relationships.
### Turning rules into code
        - Translate rules into consistent, step-based code actions.
### Sketching flow
        - Sketch a flow description that maps conditions to outcomes.
### Understanding common solution patterns
        - Recognize common patterns like dictionary lookups in simple plans and implement them in Python.
### Reviewing the plan
        - Review pseudocode to check for logical gaps or overlaps.
### From plan to working machine
        - Translate pseudocode into working Python code step by step.
### Keeping comments that connect to pseudocode
        - Keep reference comments that connect code back to pseudocode blocks.
### 10. Creating function stubs for structure
        - Write function stubs that capture intended structure.
### 11. Building code incrementally
        - Use hardcoded return values as temporary placeholders.
     - Incrementally replace stubs with working implementations.
### 12. Creating test tables for pseudocode plans
     - Create a small input-output test table for a pseudocode plan.
### 13. Dry running plans with test values
     - Conduct a dry run by walking through the plan with pseudocode test-table values.
### 14. Integrating logic into a full app
     - Integrate validated input, logic, and output formatting into a single app.
### 15. Demonstrating the working app
     - Demonstrate the app working correctly for multiple test cases.
### Weekly review: Escape room master plan
Students are trapped in a virtual escape room where guessing randomly won’t work. They must map out the precise sequence of steps to solve puzzles, write pseudocode to describe the solution path, and then implement Python code that follows the plan exactly. Testing with multiple scenarios ensures their escape strategy works under pressure.


### Writing a clear feature brief
        - Write a concise paragraph that clearly defines a feature's goal, target users, and implementation context.
### Separating purpose from technical details
        - Distinguish between purpose and technical details at this stage.
### Writing a structured problem statement
        - Translate a feature description into a structured Python problem statement (docstring) with success criteria and constraints.
### Defining example inputs and outputs
        - Define concrete example inputs and expected outputs as Python literals to illustrate normal cases, edge conditions, and invalid inputs.
### Breaking down into subproblems
        - Break the problem into clear subproblems.
### Defining subproblem inputs and outputs
        - Define the input and output of each subproblem clearly.
### Sequencing subproblems logically
        - Arrange subproblems in a logical sequence and implement them in a Python script.
### Matching subproblems to patterns
        - Match subproblems to common patterns such as filter, map, or group.
### Prioritizing tasks by risk
        - Label tasks as risky or straightforward based on uncertainty and choose a build order that addresses risk early.
### 10. Explaining prioritization choices
        - Explain rationale for prioritization decisions.
### 11. Assembling functions into pipelines
        - Assemble multiple functions into a working pipeline, showing how outputs of one feed into inputs of another.
### 12. Breaking down a case study
        - Decompose a real-world case study into subproblems.
### 13. Writing a full problem statement
        - Develop a comprehensive problem statement for a simple case study and implement a complete Python solution.
		
### Weekly review: ars pioneers
Students take on the role of space pioneers designing the first human settlement on Mars. They write a mission brief, identify vital inputs and outputs (oxygen, water, energy, food), and break the challenge into subproblems like life support, transport, and communication. By mapping data flow and assembling a Python pipeline, they create a structured plan that transforms survival on Mars into a working simulation.
