{
  "units": [
    {
      "unitTitle": "Professional coding practices",
      "lessons": [
        {
          "lessonTitle": "Welcome to CS101!",
          "masteryOutcomes": [
            "Understand the course structure and main topics"
          ]
        },
        {
          "lessonTitle": "Naming that tells a story",
          "masteryOutcomes": [
            "Rename variables and functions to improve clarity"
          ]
        },
        {
          "lessonTitle": "Crafting docstrings that explain the why",
          "masteryOutcomes": [
            "Write docstrings that explain the purpose and usage of functions"
          ]
        },
        {
          "lessonTitle": "Writing comments with real purpose",
          "masteryOutcomes": [
            "Add comments that clarify reasoning instead of obvious behavior"
          ]
        },
        {
          "lessonTitle": "Keeping it clean",
          "masteryOutcomes": [
            "Apply consistent formatting for whitespace, indentation, and line breaks"
          ]
        },
        {
          "lessonTitle": "Making code instantly readable",
          "masteryOutcomes": [
            "Rewrite code to pass a readability checklist"
          ]
        },
        {
          "lessonTitle": "Turning long scripts into sharp functions",
          "masteryOutcomes": [
            "Understand why long monolithic scripts reduce readability, reusability, and maintainability.",
            "Split a long script into focused functions with well-defined signatures."
          ]
        },
        {
          "lessonTitle": "Following program flow with print tracing",
          "masteryOutcomes": [
            "Insert print-based tracing statements to follow program execution"
          ]
        },
        {
          "lessonTitle": "Using invariants as safety checkpoints",
          "masteryOutcomes": [
            "Understand how invariants help ensure program correctness and prevent bugs.",
            "Apply invariants to check assumptions at key points in the code."
          ]
        },
        {
          "lessonTitle": "Designing functions that can be reused anywhere",
          "masteryOutcomes": [
            "Use parameters and return values to ensure modular function design"
          ]
        },
        {
          "lessonTitle": "Debugging step by step",
          "masteryOutcomes": [
            "Apply a debugging checklist to isolate and resolve defects"
          ]
        },
        {
          "lessonTitle": "Stress it to the edge",
          "masteryOutcomes": [
            "Include edge cases and invalid inputs in test coverage"
          ]
        },
        {
          "lessonTitle": "Pushing the limits",
          "masteryOutcomes": [
            "Understand how clear input and output boundaries ensure reliable, predictable program behavior.",
            "Design and implement tests that verify code correctness at boundary and edge conditions."
          ]
        },
        {
          "lessonTitle": "Validating inputs before they break things",
          "masteryOutcomes": [
            "Implement input validation to prevent unexpected behavior"
          ]
        },
        {
          "lessonTitle": "The art of a well-placed error",
          "masteryOutcomes": [
            "Write clear error messages and handle invalid inputs gracefully"
          ]
        },
        {
          "lessonTitle": "Refactoring with confidence",
          "masteryOutcomes": [
            "Perform safe refactoring moves such as renaming, extracting functions, and removing dead code"
          ]
        },
        {
          "lessonTitle": "Making sure nothing breaks",
          "masteryOutcomes": [
            "Re-run tests to confirm consistent behavior after refactoring"
          ]
        },
        {
          "lessonTitle": "Weekly review: professional coding practices",
          "masteryOutcomes": [
            ""
          ]
        }
      ]
    },
    {
      "unitTitle": "From ideas to instructions",
      "lessons": [
        {
          "lessonTitle": "Balancing planning and coding",
          "masteryOutcomes": [
            "Explain trade-offs between planning and immediate coding"
          ]
        },
        {
          "lessonTitle": "Breaking the problem",
          "masteryOutcomes": [
            "Break down a problem into ordered pseudocode steps"
          ]
        },
        {
          "lessonTitle": "Hierarchy in pseudocode",
          "masteryOutcomes": [
            "Apply numbering and indentation to represent sequence and hierarchy in pseudocode"
          ]
        },
        {
          "lessonTitle": "Turning rules into code",
          "masteryOutcomes": [
            "Translate rules into consistent code actions"
          ]
        },
        {
          "lessonTitle": "Sketching flow",
          "masteryOutcomes": [
            "Map conditions to outcomes with flow descriptions"
          ]
        },
        {
          "lessonTitle": "Understanding common solution patterns",
          "masteryOutcomes": [
            "Recognize and implement common patterns like dictionary lookups"
          ]
        },
        {
          "lessonTitle": "Reviewing the plan",
          "masteryOutcomes": [
            "Identify logical gaps or overlaps in pseudocode"
          ]
        },
        {
          "lessonTitle": "From plan to working machine",
          "masteryOutcomes": [
            "Translate pseudocode into working Python code step by step"
          ]
        },
        {
          "lessonTitle": "Keeping comments that connect to pseudocode",
          "masteryOutcomes": [
            "Maintain comments that connect code to pseudocode blocks"
          ]
        },
        {
          "lessonTitle": "Creating function stubs for structure",
          "masteryOutcomes": [
            "Write function stubs that define intended structure"
          ]
        },
        {
          "lessonTitle": "Building code incrementally",
          "masteryOutcomes": [
            "Use hardcoded return values as placeholders",
            "Replace stubs with working implementations incrementally"
          ]
        },
        {
          "lessonTitle": "Creating test tables for pseudocode plans",
          "masteryOutcomes": [
            "Build input-output test tables for pseudocode plans"
          ]
        },
        {
          "lessonTitle": "Dry running plans with test values",
          "masteryOutcomes": [
            "Perform dry runs using pseudocode test-table values"
          ]
        },
        {
          "lessonTitle": "Integrating logic into a full app",
          "masteryOutcomes": [
            "Integrate validated inputs, logic, and output formatting into one app"
          ]
        },
        {
          "lessonTitle": "Demonstrating the working app",
          "masteryOutcomes": [
            "Demonstrate working apps with multiple test cases"
          ]
        },
        {
          "lessonTitle": "Weekly review: from ideas to instructions",
          "masteryOutcomes": [
            ""
          ]
        }
      ]
    },
    {
      "unitTitle": "Breaking problems down",
      "lessons": [
        {
          "lessonTitle": "Writing a clear feature brief",
          "masteryOutcomes": [
            "Write a concise paragraph defining feature goals, target users, and context"
          ]
        },
        {
          "lessonTitle": "Separating purpose from technical details",
          "masteryOutcomes": [
            "Differentiate purpose from technical implementation details"
          ]
        },
        {
          "lessonTitle": "Writing a structured problem statement",
          "masteryOutcomes": [
            "Create structured Python problem statements with success criteria"
          ]
        },
        {
          "lessonTitle": "Defining example inputs and outputs",
          "masteryOutcomes": [
            "Provide example inputs and outputs for normal and edge cases"
          ]
        },
        {
          "lessonTitle": "Breaking down into subproblems",
          "masteryOutcomes": [
            "Decompose problems into subproblems"
          ]
        },
        {
          "lessonTitle": "Defining subproblem inputs and outputs",
          "masteryOutcomes": [
            "Define clear inputs and outputs for subproblems"
          ]
        },
        {
          "lessonTitle": "Sequencing subproblems logically",
          "masteryOutcomes": [
            "Arrange and implement subproblems in logical sequence"
          ]
        },
        {
          "lessonTitle": "Matching subproblems to patterns",
          "masteryOutcomes": [
            "Apply common coding patterns to subproblems"
          ]
        },
        {
          "lessonTitle": "Prioritizing tasks",
          "masteryOutcomes": [
            "Understand how task prioritization creates an efficient workflow that advances goals by importance and impact.",
            "Demonstrate and explain the rationale for prioritization decisions using clear criteria like impact, dependencies, risk, and effort."
          ]
        },
        {
          "lessonTitle": "Assembling functions into pipelines",
          "masteryOutcomes": [
            "Combine functions into pipelines where outputs feed subsequent inputs"
          ]
        },
        {
          "lessonTitle": "Breaking down a case study",
          "masteryOutcomes": [
            "Decompose a real-world case study into subproblems"
          ]
        },
        {
          "lessonTitle": "Writing a full problem statement",
          "masteryOutcomes": [
            "Develop comprehensive problem statements and implement solutions"
          ]
        },
        {
          "lessonTitle": "Course review: CS101 summary",
          "masteryOutcomes": [
            ""
          ]
        }
      ]
    }
  ]
}