{
  "title": "cs101-pt",
  "description": "",
  "modifiedAt": "",
  "createdAt": "2026-01-12",
  "isPublished": false,
  "trackType": "Programming",
  "version": 1,
  "terms": [
    {
      "courses": [
        {
          "title": "cs101-pt",
          "description": "",
          "displayId": "",
          "credits": 0,
          "units": [
            {
              "title": "Readable Code Foundations",
              "lessons": [
                {
                  "title": "Welcome to CS101!",
                  "masteryOutcomes": [
                    "Understand the course structure and main topics"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Naming that tells a story",
                  "masteryOutcomes": [
                    "Rename variables and functions to improve clarity"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Crafting docstrings that explain the why",
                  "masteryOutcomes": [
                    "Write docstrings that explain the purpose and usage of functions"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Course concepts and naming clarity",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Practice identifying good course habits, better names, and helpful docstrings by analyzing and improving short code and description snippets.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Writing comments with real purpose",
                  "masteryOutcomes": [
                    "Add comments that clarify reasoning instead of obvious behavior"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Keeping it clean",
                  "masteryOutcomes": [
                    "Apply consistent formatting for whitespace, indentation, and line breaks"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Study timer formatter",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Apply purposeful comments and consistent formatting to a small ‚Äústudy session timer‚Äù script so another student can easily understand and maintain it. Output: A neatly formatted study-timer script with meaningful comments that explain reasoning and edge cases rather than restating obvious behavior.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Expense tracker notes",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Refactor a simple personal expense tracker script to improve indentation, line breaks, and comment quality so that its logic reads like a clear narrative. Output: A cleaned-up expense tracker script whose structure and comments make its flow and decisions immediately understandable.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Making code instantly readable",
                  "masteryOutcomes": [
                    "Rewrite code to pass a readability checklist"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Turning long scripts into sharp functions",
                  "masteryOutcomes": [
                    "Understand why long monolithic scripts reduce readability, reusability, and maintainability.",
                    "Split a long script into focused functions with well-defined signatures."
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Quiz grader refactor - Part 1",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Rewrite a messy ‚Äúonline quiz grader‚Äù script to improve readability using naming, structure, and a readability checklist without yet changing it into multiple functions. Output: A single-file quiz grading script that still runs the same but is significantly easier to read and reason about.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Quiz grader refactor - Part 2",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Decompose the readable quiz grader script into focused functions with clear signatures to improve reuse and maintainability. Output: A modular quiz grading program composed of well-named functions that handle input parsing, scoring, and result reporting separately.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Following program flow with print tracing",
                  "masteryOutcomes": [
                    "Insert print-based tracing statements to follow program execution"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Using invariants as safety checkpoints",
                  "masteryOutcomes": [
                    "Understand how invariants help ensure program correctness and prevent bugs.",
                    "Apply invariants to check assumptions at key points in the code."
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Habit tracker debugger - Part 1",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Insert print-based tracing into a small ‚Äúdaily habit tracker‚Äù script to follow program flow and locate a subtle logic issue in streak calculation. Output: A traced version of the habit tracker that prints step-by-step progress and reveals where the streak logic goes wrong.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Habit tracker debugger - Part 2",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Define and enforce invariants at key points in the habit tracker (e.g., streak counts, date ordering) to prevent regressions and catch future bugs early. Output: An updated habit tracker script that uses invariant checks (assertions or conditional guards) to validate its internal state during execution.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                }
              ]
            },
            {
              "title": "Robust Code Habits",
              "lessons": [
                {
                  "title": "Stress it to the edge",
                  "masteryOutcomes": [
                    "Include edge cases and invalid inputs in test coverage"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Pushing the limits",
                  "masteryOutcomes": [
                    "Understand how clear input and output boundaries ensure reliable, predictable program behavior.",
                    "Design and implement tests that verify code correctness at boundary and edge conditions."
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Validating inputs before they break things",
                  "masteryOutcomes": [
                    "Implement input validation to prevent unexpected behavior"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Budget validator",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Practice designing input boundaries, edge-case tests, and validation rules for a simple budgeting tool to ensure predictable behavior. Output: A script that accepts income and expense entries, rejects invalid or suspicious inputs, and reports whether the monthly budget is valid or not.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "The art of a well-placed error",
                  "masteryOutcomes": [
                    "Write clear error messages and handle invalid inputs gracefully"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Refactoring with confidence",
                  "masteryOutcomes": [
                    "Perform safe refactoring moves such as renaming, extracting functions, and removing dead code"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Quiz score analyzer - Part 1",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Practice writing clear, user-friendly error messages and handling invalid inputs gracefully in a quiz score analyzer. Output: A script that asks for quiz scores, detects and reports invalid inputs with precise error messages, and safely recovers to re-ask for correct values.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Quiz score analyzer - Part 2",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Practice refactoring an existing script (from Part 1) by renaming, extracting functions, and removing dead code while preserving behavior. Output: A cleaner, modular quiz score analyzer script with the same behavior and improved structure and readability.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Making sure nothing breaks",
                  "masteryOutcomes": [
                    "Re-run tests to confirm consistent behavior after refactoring"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Habit tracker refactor tests - Part 1",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Practice running and extending tests to verify that a small habit-tracking script still behaves correctly after small code changes. Output: A set of passing tests that confirm the habit tracker‚Äôs core features (adding, listing, and marking habits) work as expected.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Professional coding self-review - Part 2",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Reflect on and assess your own coding practices using a structured checklist, identifying strengths and specific improvement targets. Output: A short written self-review document that maps your current habits to professional practices and lists 3-5 concrete improvement goals.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Balancing planning and coding",
                  "masteryOutcomes": [
                    "Explain trade-offs between planning and immediate coding"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Breaking the problem",
                  "masteryOutcomes": [
                    "Break down a problem into ordered pseudocode steps"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Planning vs coding trade-offs",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Analyze scenarios and decide when more planning or faster coding is appropriate, explaining the trade-offs in each case.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Study planner pseudocode",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Practice breaking a real-world problem into ordered pseudocode steps for a simple study-planning tool. Output: A clear pseudocode outline that describes how a study planner would take tasks, estimate time, and produce an ordered study plan.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                }
              ]
            },
            {
              "title": "Structured Problem Solving",
              "lessons": [
                {
                  "title": "Sketching flow",
                  "masteryOutcomes": [
                    "Map conditions to outcomes with flow descriptions"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Understanding common solution patterns",
                  "masteryOutcomes": [
                    "Recognize and implement common patterns like dictionary lookups"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Reviewing the plan",
                  "masteryOutcomes": [
                    "Identify logical gaps or overlaps in pseudocode"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Study planner flow",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Practice mapping conditions to outcomes, spotting common solution patterns, and reviewing a pseudocode plan for logical gaps using a study-planner scenario.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "From plan to working machine",
                  "masteryOutcomes": [
                    "Translate pseudocode into working Python code step by step"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Keeping comments that connect to pseudocode",
                  "masteryOutcomes": [
                    "Maintain comments that connect code to pseudocode blocks"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Movie night recommender",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Translate a short pseudocode plan into working Python step by step while preserving comments that map each code block to the original plan. Output: A script that recommends a movie type (e.g., ‚Äúcomedy series‚Äù, ‚Äúaction movie‚Äù) based on mood, available time, and who you‚Äôre watching with.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Habit tracker summary",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Strengthen the habit of writing code directly from pseudocode while keeping clear, structured comments that trace each part of the implementation back to the plan. Output: A script that takes a list of daily habit completions and prints a short weekly summary (days completed, streaks, and a simple encouragement message).",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Creating function stubs for structure",
                  "masteryOutcomes": [
                    "Write function stubs that define intended structure"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Building code incrementally",
                  "masteryOutcomes": [
                    "Use hardcoded return values as placeholders",
                    "Replace stubs with working implementations incrementally"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Budget helper functions - Part 1",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Practice designing and writing function stubs that define the structure of a small budgeting tool before any real logic is implemented. Output: A Python file with multiple clearly named function stubs and placeholder return values that outline a personal budget helper.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Budget helper functions - Part 2",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Incrementally replace stubs and hardcoded return values with working implementations while keeping the overall structure stable. Output: A script that can accept some expense and income values, then compute and print remaining budget and simple spending advice.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Creating test tables for pseudocode plans",
                  "masteryOutcomes": [
                    "Build input-output test tables for pseudocode plans"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Dry running plans with test values",
                  "masteryOutcomes": [
                    "Perform dry runs using pseudocode test-table values"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Quiz grading plan tests",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Practice creating detailed input-output test tables for a quiz-grading pseudocode plan, including edge cases and typical cases.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Fitness tracker dry runs",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Strengthen dry-running skills by walking through pseudocode with test-table values and tracing intermediate steps to verify correctness.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                }
              ]
            },
            {
              "title": "Structured Problem Design",
              "lessons": [
                {
                  "title": "Writing a clear feature brief",
                  "masteryOutcomes": [
                    "Write a concise paragraph defining feature goals, target users, and context"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Separating purpose from technical details",
                  "masteryOutcomes": [
                    "Differentiate purpose from technical implementation details"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Habit tracker feature brief",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: You will be able to write a clear feature brief that separates the purpose of a tool from its technical implementation details and reflect on how planning and pseudocode guide better code.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Writing a structured problem statement",
                  "masteryOutcomes": [
                    "Create structured Python problem statements with success criteria"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Defining example inputs and outputs",
                  "masteryOutcomes": [
                    "Provide example inputs and outputs for normal and edge cases"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Quiz generator problem statement",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: You will be able to write a structured Python problem statement for a simple quiz generator, including clear success criteria and example inputs/outputs for normal and edge cases. Output: A written problem statement document describing what a future quiz-generator script will do, with tables of sample inputs and outputs.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Budget checker examples",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: You will be able to define precise example inputs and outputs (including edge cases) for a personal budget-checking tool based on a structured problem statement. Output: A set of labeled test cases (inputs and expected outputs) that could later be used to validate a budget-checker script.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Breaking down into subproblems",
                  "masteryOutcomes": [
                    "Decompose problems into subproblems"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Defining subproblem inputs and outputs",
                  "masteryOutcomes": [
                    "Define clear inputs and outputs for subproblems"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Study planner subproblems",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: You will be able to decompose a study-planning tool into clear subproblems and define the inputs and outputs for each subproblem. Output: A structured list (or table) of subproblems with their corresponding input and output definitions, ready to guide later coding.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Content tagger subproblem I/O",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: You will be able to refine and formalize subproblem boundaries and their input/output contracts for a simple content-tagging helper. Output: A documented set of subproblem interfaces (names, inputs, and outputs) that could be translated directly into function signatures.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Sequencing subproblems logically",
                  "masteryOutcomes": [
                    "Arrange and implement subproblems in logical sequence"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Matching subproblems to patterns",
                  "masteryOutcomes": [
                    "Apply common coding patterns to subproblems"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Task scheduler flow - Part 1",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: You will be able to arrange previously defined subproblems for a simple task scheduler into a logical sequence and justify the ordering. Output: A step-by-step flow (numbered list or flowchart-style description) showing the order in which a future script would execute its subproblems.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Task scheduler flow - Part 2",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: You will be able to match each subproblem in the task scheduler flow to common coding patterns (e.g., input-validation loop, filter-then-sort, accumulator) and outline how those patterns will be applied. Output: A mapping from subproblems to coding patterns, with brief pattern-focused pseudocode sketches for the eventual script.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                }
              ]
            }
          ],
          "label": "",
          "teachingInstructions": "",
          "durationInWeeks": 4,
          "isPublished": false
        }
      ]
    }
  ]
}