### Writing your first program
 - Introduce the Maestro Code Editor
 - Write and execute a simple Python script using the print() function

### Unlocking print() power-ups
 - Print multiple values using commas
 - Understand that printing is always in a new line
 - Print multiple text and numeric values using the + and * operators
 - Predict the output of a script that uses multiple print() statements

### Creating art with code
 - Decide on a simple visual pattern you can create using prints, and challenge the student to create it
 - Define what ASCII is and explain how ASCII characters can be used to create images and patterns
 - Generate a multi-line ASCII art pattern using any print method

### Introduction to variables
 - Explain that a variable is a named placeholder for a value in memory
 - Write a valid variable name following Python conventions
 - Assign a value (e.g., a number or a piece of text) to a variable using the = operator
 - Use the print() function to display the value stored in a variable

### Working with text
 - Define a "data type" as a category of data that determines what you can do with it
 - Create a string variable by enclosing text in single (') or double (") quotes
 - Combine two strings using the + operator (concatenation)
 - Predict the output when printing string variables

### Working with numbers
 - Distinguish between an integer (int, a whole number) and a float (float, a number with a decimal)
 - Create variables to store integer and float values
 - Perform basic arithmetic operations (+, -, *, /) on numeric variables
 - Explain why 5 is different from "5"

### Checking the facts
 - Use the type() function to check the data type of a variable's value
 - Correctly identify str, int, and float types in the output of the type() function
 - Explain the purpose of the type() function as a way to understand your data

### Understanding type errors and f-strings
 - Identify and explain a TypeError that occurs when attempting to combine incompatible data types (e.g., print("Age: " + 25))
 - Embed variables of any type directly inside a string using f-string syntax (f"...")
 - Combine text and variables to produce a clean, readable, and dynamic output

### Type casting
 - Use the str(), int(), and float() functions to convert values between data types
 - Predict the outcome of valid type conversions (e.g., int("123"))
 - Identify cases where a conversion will fail and result in a ValueError (e.g., int("hello"))

### Create your personal profile
 - Define and use variables of str, int, and float types to represent personal data (e.g., name, age, hourly_rate)
 - Use the type() function to verify the data types of the created variables
 - Use f-strings to combine all the variables into a multi-line, well-formatted "profile card" output
 - Write a short, commented script that is readable and error-free

### Create the bot's logo
 - Articulate the overall goal of the project: to build a multi-part, text-based bot
 - Design a simple but unique visual pattern using multiple print() statements
 - Combine strings and special characters to create a multi-line ASCII art logo
 - Write clean, readable code for the visual component of the final script

### Give the bot a skill
 - Use variables to store and manipulate numerical data
 - Perform a multi-step arithmetic calculation using the variables you created
 - Use an f-string to embed the results of the calculation into a clean, human-readable sentence

### Assemble your bot
 - Synthesize code from previous lessons into a single, sequential Python script
 - Add comments (#) to explain the different sections of the program (logo, introduction, calculation)
 - Execute a complete, multi-part program that runs without errors from top to bottom


### Expressions and operator precedence

- Control the order of expression evaluation in Python through operator precedence and parentheses.

### Updating values and printing expressions

- Update numeric variables with compound assignment (+=, -=) and predict final values.
- Print expressions that mix numbers and text (via commas) and explain the output behavior.

### Modeling real-world calculations

- Translate a two-step word problem into an arithmetic expression and compute the result.
- Do arithmetic directly inside print() to produce clear, useful outputs.
- Compare two equivalent formulations and choose the clearer one.

### Division modes: / vs // with quotient and remainder

- Compute and contrast true division (/) and floor division (//) on integers
 - explain the difference.
- Use // and % together to derive quotient and remainder for practical cases (e.g., packing/scheduling).

###  Modulo in practice: parity, cycles, positions

- Use x % 2 to detect parity and explain why it works.
- Apply modulo to cyclic positions (e.g., every Nth item, rotating shifts) to simplify branching.

### Rounding, and money format

- Use round(x, n) to control numeric precision.
- Format prices with f"{x:.2f}" as a quick money-format (value vs representation).

###  Talking to your program: getting input from users

- Explain why programs interact with users and when input() is appropriate
 - collect input with clear prompts.
- Convert numeric inputs to the correct type before computing and print a friendly summary.

###  Functions i: why, define, and call

- Understand how functions reduce repetition and improve reuse.
- Understand the structure of Python functions.
- Define a function with one or two parameters and call it with literals and variables.

###  Functions ii: Inside the function

- Understand the structure of a function, including its name, parameters, indentation, and return value.
- Call functions with arguments correctly and trace how values are passed from the call site to parameters, verifying the flow using print statements.

###  Functions iii: return vs print and early return

- Differentiate printing vs returning values.
- Use return to pass results and apply early returns.

###  Scope and local variables

- Understand that variables created inside a function exist only within that function’s scope (local).
- Explain how local and global scopes differ and identify when each is used.
- Demonstrate how data can be passed into functions through parameters instead of relying on global variables.

### Python errors: meet the traceback

- Identify key parts of a traceback, including the error type, and a short explanation of what went wrong.

###  Introduction to debugging

- Define debugging as the process of finding and fixing errors in a program.
- Use print statements to observe variable values and trace the program’s flow step by step.
- Insert and remove targeted print statements to test assumptions and confirm how the code behaves.

###  Weekly review: Café receipt
Create a program that acts as a mini receipt calculator. 


###  Control flow overview: decisions vs repetition

- Identify when a task requires selection (if/else) versus repetition (loop) and provide an example of each.
- Write a 3–5 line text-only flow outline in comments and map each line to if/else or loop constructs.

###  If/else: syntax, indentation, mental model

- Introduce indentation as Python’s rule for defining code blocks.
- Write a basic if/else using comparison operators (==, !=, <, >, <=, >=).
- Differentiate assignment (=) from equality (==) in conditions.

###  Logical operators: and/or/not and short-circuiting

- Combine comparisons with and, or, not to form compound conditions.
- Show short-circuit behavior by adding prints to the right-hand side expression.

###  Booleans and comparisons: equality vs identity

- Use True/False in expressions and store boolean results in variables.
- Differentiate between '==' (value equality) and 'is' (identity equality).

###  String membership with 'in' in conditions

- Test substring membership with 'in' and negate with 'not in'.
- Use membership checks inside if/elif branches to drive simple decisions.

###  Elif and refactoring nested decisions

- Refactor a nested if/else into an equivalent if/elif/else chain.
- Order conditions to avoid overlaps and unreachable branches.

###  Decision tables to branching logic

- Translate a 3–5 row decision table into clear if/elif/else code.
- Verify mutual exclusivity and completeness of the conditions.

###  For loops and range(): counting iterations

- Write for loops with range(stop), range(start, stop), range(start, stop, step).
- Accumulate a total across iterations and print the result.
- Generate even/odd sequences and countdowns with range.

###  Meet the while loop

- Understand what a while loop is and when it is more suitable than for.
- Understand the risk of infinite loops and explain how to prevent them.
- Write a while loop to repeat actions until a condition changes.

###  Loop control: break and continue

- Understand when to exit a loop early with break versus letting it complete naturally.
- Insert break to exit early on a condition and continue to skip an iteration.

###  Counters and totals

- Initialize and update a counter and running total correctly inside a loop.
- Print the final counts and totals after the loop completes.

###  Weekly Review: Score trackerScore tracker
You need to build a score tracker program. The program should prompt the user to enter the names of two teams and set a maximum score that determines when the game ends.  After that, the program should repeatedly ask the user to enter the updated scores for each team.


###  String skills upgrade i: indexing and slicing

- Access individual characters in a string using 0-based indexing.
- Use slice notation [start:stop] and [start:stop:step] to extract substrings.
- Use negative indices to access characters from the end of a string.

###  String skills upgrade ii: common methods

- Use strip, lower, replace, and find to clean and search text.

###  String skills upgrade iii: splitting and joining text

- Split delimited lines into fields and re-join using a chosen delimiter.
- Handle extra whitespace and empty fields during splitting.

###  Lists i: creating lists

- Create lists with literals and from range()
 - print length with len().
- Explain that lists are mutable and show a visible effect of mutation.
- Understand when a list is a better choice than separate variables.

###  Lists ii: indexing and slicing

- Access list elements by index and understand how indexing works.
- Modify list elements and create sublists using slicing.
- Handle out-of-range errors (IndexError) in list access.

### Lists iii: mastering list iteration

- Use a for loop with range() and len() to iterate over indices and access list elements by their position.
- Use a for loop to iterate directly over the values in a list and perform actions on each element.

###  Lists iv: common methods

- Modify a list in place with append, insert, remove, pop, and extend.

###  Ordering lists: sorted() vs .sort()

- Sort a list in place with .sort() and create a sorted copy with sorted().
- Use .sorted() parameters ('key' and 'reverse') to customize ordering and explain stability.

###  Dictionaries i: keys and values

- Create dictionaries and access values by key
 - add and update key–value pairs.
- Explain valid key types and why mutability matters for keys.

###  Dictionaries ii: iteration patterns

- Iterate over a dictionary’s keys, values, and key–value pairs.
- Select the most suitable iteration pattern (keys, values, or items) based on the task’s goal.

###  Updates and copy semantics

- Show the difference between assignment (aliasing) and shallow copy for lists and dicts.
- Explain that list slicing (x[:]) creates a new list independent of the original.
- Use list(x) / x.copy() / dict(x) appropriately to avoid unintended aliasing.

###  Nested structures and safe mutation

- Access and modify data inside nested lists and dictionaries step by step.
- Use safe methods like get() to read values.

###  Parsing text to list of dicts: tokenize and map fields

- Map split fields into a dict with named keys for a single line.
- Extend the approach to multiple lines to build a list of dicts.

###  Weekly Review: Personal music manager
 - Build a program that helps a user manage their music playlist. Students will create a list of song dictionaries (title, artist, duration, genre), add and remove songs, sort the playlist by different fields, and display summaries like total songs by genre or average duration.