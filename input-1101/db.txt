## Unit 1 - Data Has Shape

### 1. Why Databases Exist

- Explain what a database is and what problems it solves.
- Distinguish databases from files and in-memory data.
- Identify data in real applications that belongs in a database.

### 2. What Is a Relational Database

- Define relational databases as tables connected by relationships.
- Describe rows, columns, and tables using concrete examples.
- Explain why relationships matter for real-world data.

### 3. DBMS: The Software Behind the Data

- Define DBMS and distinguish it from a database.
- Name common relational DBMSs (e.g., SQLite, PostgreSQL).
- Explain at a high level how a DBMS stores data and executes queries.

### 4. Tables, Rows, Columns

- Describe how relational databases organize data using tables.
- Explain the role of rows and columns in storing structured data.
- Identify when a table mixes multiple real-world concepts incorrectly.

### 5. Primary Keys

- Define a primary key as a column that uniquely identifies a row.
- Explain why tables need stable values that other tables can reference.
- Select an appropriate primary key based on real-world data.

### 6. Designing a Schema

- Define schema as the set of tables and columns in a database.
- Design tables from a short real-world story (entities → tables).
- Assign attributes to tables to avoid duplication and confusion.

### 7. Foreign Keys

- Define foreign keys and how they reference primary keys.
- Model a one-to-many relationship using PK and FK.
- Explain how foreign keys enable JOIN queries.

### 8. Reading ER Diagrams

- Identify tables and key columns in a physical ER diagram.
- Interpret relationship lines as FK → PK connections.
- Translate an ER diagram into tables.

### 9. Hello, SQL!

- Define SQL and describe what kind of language it is (declarative).
- Explain what is the role of SQL vs DMBS.
- Recognize SQL as the interface for querying relational databases.
- Get to know the  basic syntax and structure of SQL using a simple SELET query.

### 10. More about SELECT

- Write basic queries that retrieve specific columns from a table.
- Learn how to get only specific columns and how to alias columns.

### 11. Reading Query Results

- Predict query results by reading SQL statements.
- Explain what each row in a result set represents.
- Debug simple queries.

---

## Unit 2 - Asking Questions with SQL

### 1. SQL: How Queries Are Written

- **Describe** SQL as a declarative query language.
- **Explain** the structure of a SQL statement.
- **Distinguish** SQL from procedural languages like Python.

---

### 2. Picking Columns on Purpose

- **Write** SELECT queries with specific columns.
- **Use** column aliases to rename output.
- **Explain** how selected columns relate to the schema.

---

### 3. Filtering with WHERE

- **Write** WHERE clauses using comparison operators.
- **Filter** results based on realistic conditions.
- **Debug** incorrect filtering logic.

---

### 4. AND vs OR

- **Distinguish** AND from OR using concrete examples.
- **Combine** multiple conditions correctly.
- **Explain** filter logic in plain language.

---

### 5. Pattern Matching with LIKE

- **Use** LIKE to match partial text.
- **Choose** between exact match and pattern match.
- **Write** readable LIKE patterns.

---

### 6. IN and BETWEEN

- **Filter** using IN for multiple values.
- **Filter** using BETWEEN for ranges.
- **Choose** the clearest filtering approach.

---

### 7. NULL Means Missing

- **Define** NULL and distinguish it from empty values.
- **Write** IS NULL and IS NOT NULL conditions.
- **Predict** how NULL affects query results.

---

### 8. Sorting Results

- **Sort** query results using ORDER BY.
- **Choose** meaningful sorting directions.
- **Explain** the difference between filtering and sorting.

---

### 9. Limiting Output

- **Use** LIMIT to control result size.
- **Combine** WHERE, ORDER BY, and LIMIT.
- **Validate** that results match the question asked.

---

### 10. JOIN: Bringing Tables Together

- **Explain** why data is split across tables.
- **Identify** join keys using PK and FK.
- **Write** a basic JOIN query.

---

### 11. From Diagram to Query

- **Identify** join paths from ER diagrams.
- **Write** JOIN queries across two tables.
- **Modify** queries with filtering and sorting.

---

## **Unit 3 SQLite: Our First Real Database**

### 1. What Is SQLite?

- **Explain** what SQLite is and how it differs from server-based DBMSs.
- **Identify** common scenarios where SQLite is an appropriate choice.
- **Recognize** SQLite as a fully relational database.

---

### 2. SQLite with user interface

- **Open** and explore a SQLite database using a graphical interface (DB Browser).
- **Identify** tables, columns, and relationships visually.
- **Connect** UI actions to the underlying database concepts.

---

### 3. Creating Tables

- **Create** tables using a graphical database tool.
- **Define** columns with appropriate data types.
- **Set** primary keys and foreign keys using the UI.

---

### 4. Designing a Database from a Story

- **Translate** a real-world description into relational tables.
- **Choose** appropriate columns and primary keys.
- **Implement** the schema using a graphical tool.

---

### 5. Inserting and Editing Data

- **Insert** rows into tables using the UI.
- **Respect** foreign key relationships when adding data.
- **Explain** common data-entry errors caused by schema constraints.

---

### 6. Querying Data (UI + SQL)

- **Run** basic `SELECT` queries using the built-in query editor.
- **Inspect** query results in a tabular interface.
- **Relate** query output to the underlying tables and relationships.

---

### 7. SQLite in the Database Landscape

- **Summarize** SQLite’s role among relational DBMSs.
- **Contrast** UI-based database interaction with writing raw SQL.
- **Explain** why relational databases are often the default choice.

## Unit 4 — NoSQL in Context

### 1. Beyond Relational: The NoSQL Landscape

- **Define** NoSQL as a family of non-relational databases.
- **Distinguish** relational databases from NoSQL at a high level.
- **Identify** major NoSQL types: document, key-value, wide-column, graph.
- **Recognize** which NoSQL types are covered in this course.

### 2. JSON: The Shape of Modern Data

- **Define** JSON and its core structures, bulduing on knowledge from Python’s dicts.
- **Read** JSON and explain the data it represents.
- **Relate** JSON to Python dictionaries and lists.

---

### 3. Document Databases

- **Define** documents and collections.
- **Explain** how document databases store data.
- **Identify** common use cases.
- **Recognize** MongoDB as a common example.

---

### 4. Key-Value Stores

- **Define** key-value storage.
- **Explain** what key-value stores are good at.
- **Contrast** key-value access with SQL querying.
- **Recognize** Redis as a common example.

---

### 5. Choosing the Right Tool

- **Recommend** relational, document, or key-value storage for simple scenarios.
- **Justify** choices using course vocabulary.
- **Explain** why relational databases are usually the default.