## Unit 1: Plan the App, Set Up the Project

---

### 1. Project Goal and Scope

- Choose an app idea that fits your API
- Define in-scope vs out-of-scope features
- List the minimum “done” feature set

### 2. UX vs UI

- Distinguish **UI** vs **UX** in plain terms
- Identify 3 UX requirements for any CRUD app (loading, errors, empty states)
- Add UX notes to the project plan (what the user sees)

### 3. User Stories

- Write 4–6 user stories for your app (list, detail, create, edit, login optional)
- Keep stories small and testable
- Prioritize stories (must-have vs nice-to-have)

### 4. Wireframes: Core Screens

- Create wireframes for 3–4 screens (list, detail, create/edit, login optional)
- Label key UI elements (inputs, buttons, messages)
- Ensure wireframes match your stories

### 5. Map Screens to Endpoints

- List your API endpoints (method + path)
- Map each screen to the endpoints it needs
- Identify which endpoints require auth (if any)

### 6. Data Flow Basics

- Describe one read flow (load list → render)
- Describe one write flow (submit form → update UI)
- Include loading/error/success outcomes

### 7. Vite Setup and API Base URL

- Create a React app with Vite and run it locally
- Store API base URL in an env var (`VITE_API_BASE_URL`)
- Confirm you can hit one endpoint from the browser, if needed you can disable auth for now

### 8. Why Routing Exists

- Explain what routing solves in a React single-page app (different URLs → different screens)
- Distinguish a “page” component from a reusable component
- Identify which screens in the project should become routes

### 9. React Router: Setup + Links

- Install and set up React Router in a Vite app
- Create routes for core pages (Home/List, Create, Login optional)
- Add navigation with `Link` and confirm it works locally

## Unit 2: Reading Data, UX States

---

### 1. Dynamic Routes: Detail Pages

- Understand and learn the syntax for dynamic routes in react router
- Understand the useParams hook and why we use it
- Handle “not found” cleanly

### 2. Shared Layout and Navigation

- Create a layout component with nav + page content
- Keep layout consistent across routes
- Organize files into `pages/` and `components/`

### 3. API Helper Function

- Create a reusable `apiFetch()` helper (base URL + JSON)
- Handle errors with a clear message
- Reuse it across multiple pages

### 4. List Page: Fetch and Render

- Fetch a list and render it using `map`
- Use stable keys correctly
- Make the items clickable if there is a details page

### 5. Detail Page: Fetch and Render

- Fetch details using the route param
- Show loading while waiting
- Show an error state on failure

### 6. UX States: Loading

- Add a loading state that is visible and consistent
- Disable buttons while loading when needed
- Confirm loading behavior in the UI

### 7. UX States: Error + Retry

- Display meaningful error messages
- Add a retry action (button or refresh)
- Confirm error behavior by breaking the API URL

### 8. Integration Check

- Confirm list + detail routes work end-to-end
- Confirm loading/error/empty states exist
- Update your plan if reality differs from wireframes

## Unit 3: Forms, Writing Data, and Auth

---

### 1. Controlled Inputs

- Bind an input to state and update via `onChange`
- Use controlled inputs for text/number fields
- Debug “input doesn’t type” issues

### 2. Form Submit Basics

- Handle form submit with `onSubmit`
- Use `preventDefault()` to stop reload
- Use submitted values in an API request

### 3. Create Flow (POST)

- Send a POST request with form data
- Handle success (navigate to list or detail)
- Show server errors in the UI

### 4. Edit Flow (PATCH/PUT)

- Pre-fill a form using fetched data
- Submit an update request
- Update the UI after success

### 5. Delete Flow

- Delete an item with a button
- Confirm the action (simple confirmation)
- Remove item from UI after success

### 6. Auth: Login UI (Optional but common)

- Build a login form and send credentials
- Store token in `localStorage`
- Handle login errors clearly

### 7. Token in API Calls

- Add `Authorization: Bearer <token>` when token exists
- Confirm protected endpoints work only when logged in
- Show “not logged in” UI guidance

### 8. Protected Routes (If Auth Exists)

- Block access to create/edit routes when logged out
- Redirect to login (or show a message)
- Keep logic simple and predictable

### 9. Authorization Responses (401 vs 403)

- Distinguish 401 (not logged in) vs 403 (not allowed)
- Show a clear UI message for each
- Disable/hide actions when appropriate

## Unit 4: Polish, Testing, and Final Delivery

---

### 1. UI Consistency Pass

- Make buttons/inputs consistent across pages
- Use reusable components where helpful
- Remove duplicated UI code

### 2. UX Improvements

- Add better empty states
- Add success feedback (message or redirect)
- Prevent double submits (disable during submit)

### 3. Effect Dependencies That Make Sense

- Choose sensible dependencies for fetch effects
- Prevent infinite loops from state updates in effects
- Fix “fetch runs too often” problems

### 4. Manual Testing Checklist

- Write a checklist for core flows (read/create/edit/delete)
- Include failure cases (API down, invalid input)
- Include auth checks if applicable

### 5. Build and Preview Locally

- Build the app (`npm run build`)
- Preview it (`npm run preview`)
- Fix any build-only issues

### 6. Environment and Config

- Use env vars for API base URL and any other sensitive information
- Confirm instructions work on a new machine
- Avoid hardcoded URLs

### 7. Project README

- Add setup steps + environment variables
- List routes and features
- Document known limitations / next steps

### 8. Final Bug Fix Round

- Fix top issues discovered during testing
- Remove console errors
- Confirm flows still work end-to-end

### 9. Demo Walkthrough

- Prepare a short demo flow (happy path)
- Show one error state (proof of UX handling)
- Explain your scope decisions (what you built vs skipped)