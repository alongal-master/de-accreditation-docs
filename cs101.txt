
### 1. **Naming that tell a story**
    - Demonstrate the ability to rename variables and functions to improve clarity.
### 2. **Crafting docstrings that explain the why**
    - Add clear docstrings that explain the purpose and usage of functions.
### 3. **Writing comments with real purpose**
    - Add purposeful comments that explain reasoning, not obvious code behavior.
### 4. **Keeping it clean**
    - Apply consistent formatting rules for whitespace, indentation, and line breaks.
### 5. **Making code instantly readable**
     - Rewrite code to pass a readability checklist you define.
### 6. **Turning long scripts into sharp functions**
    - Split a long script into focused functions with well-defined signatures.
### 7. **Following program flow with print tracing**
    - Insert print-based tracing statements to follow program flow.
### 8. **Using invariants as safety checkpoints**
    - Apply invariants to check assumptions at key points in the code.
### 9. **Designing functions that can be reused anywhere**
    - Use parameters and return values to ensure modular, reusable design.
### 10. **Debugging step by step**
    - Use a minimal debugging checklist to isolate a defect in a provided snippet.
### 11. **Stress it to the edge**
    - Include edge cases and invalid inputs in tests.
### 12. **Pushing the limits**
    - Define and test clear input and output boundaries, ensuring the code behaves correctly at limits and under invalid conditions.
### 13. **Validating inputs before they break things**
    - Add input validation to a function to prevent unexpected behavior.
###  **The art of a well-placed error**
    - Write clear error messages and handle invalid inputs gracefully.
### **Refactoring with confidence**
    - Perform safe refactoring moves such as renaming, extracting functions, and removing dead code.
### **Making sure nothing breaks**
    - Re-run tests to confirm behavior remains consistent after refactoring.
### Weekly Review:  Grandma’s secret recipe
Grandma wrote a script to calculate ingredient quantities for her famous cookie recipe, but it is a mess. Students refactor her kitchen code by splitting it into neat functions, adding docstrings that “tell the story” of the recipe steps, and validating edge cases (like zero or negative servings). They write tests to ensure the recipe always scales correctly.



- Lessons
### 1. **Balancing planning and coding**
        - Understand the trade-offs between planning and coding immediately and how upfront planning improves clarity and reduces rework.
### 2. **Breaking the problem**
        - Break down a problem into precise, ordered pseudocode steps.
### 3. **Hierarchy in pseudocode**
        - Understand pseudocode concepts and apply numbering and indentation to clearly represent sequence and hierarchical relationships.
### 4. **Turning rules into code**
        - Translate rules into consistent, step-based code actions.
### 5. **Sketching flow**
        - Sketch a flow description that maps conditions to outcomes.
### 6. **Understanding common solution patterns**
        - Recognize common patterns like dictionary lookups in simple plans and implement them in Python.
### 7. **Reviewing the plan**
        - Review pseudocode to check for logical gaps or overlaps.
### 8. **From plan to working machine**
        - Translate pseudocode into working Python code step by step.
### 9. **Keeping comments that connect to pseudocode**
        - Keep reference comments that connect code back to pseudocode blocks.
### 10. **Creating function stubs for structure**
        - Write function stubs that capture intended structure.
### 11. **Building code incrementally**
        - Use hardcoded return values as temporary placeholders.
     - Incrementally replace stubs with working implementations.
### 12. **Creating test tables for pseudocode plans**
     - Create a small input-output test table for a pseudocode plan.
### 13. **Dry running plans with test values**
     - Conduct a dry run by walking through the plan with pseudocode test-table values.
### 14. **Integrating logic into a full app**
     - Integrate validated input, logic, and output formatting into a single app.
### 15. **Demonstrating the working app**
     - Demonstrate the app working correctly for multiple test cases.
### Weekly review: Escape room master plan
Students are trapped in a virtual escape room where guessing randomly won’t work. They must map out the precise sequence of steps to solve puzzles, write pseudocode to describe the solution path, and then implement Python code that follows the plan exactly. Testing with multiple scenarios ensures their escape strategy works under pressure.


### 1. **Writing a clear feature brief**
        - Write a concise paragraph that clearly defines a feature's goal, target users, and implementation context.
### 2. **Separating purpose from technical details**
        - Distinguish between purpose and technical details at this stage.
### 3. **Writing a structured problem statement**
        - Translate a feature description into a structured Python problem statement (docstring) with success criteria and constraints.
### 4. **Defining example inputs and outputs**
        - Define concrete example inputs and expected outputs as Python literals to illustrate normal cases, edge conditions, and invalid inputs.
### 5. **Breaking down into subproblems**
        - Break the problem into clear subproblems.
### 6. **Defining subproblem inputs and outputs**
        - Define the input and output of each subproblem clearly.
### 7. **Sequencing subproblems logically**
        - Arrange subproblems in a logical sequence and implement them in a Python script.
### 8. **Matching subproblems to patterns**
        - Match subproblems to common patterns such as filter, map, or group.
### 9. **Prioritizing tasks by risk**
        - Label tasks as risky or straightforward based on uncertainty and choose a build order that addresses risk early.
### 10. **Explaining prioritization choices**
        - Explain rationale for prioritization decisions.
### 11. **Assembling functions into pipelines**
        - Assemble multiple functions into a working pipeline, showing how outputs of one feed into inputs of another.
### 12. **Breaking down a case study**
        - Decompose a real-world case study into subproblems.
### 13. **Writing a full problem statement**
        - Develop a comprehensive problem statement for a simple case study and implement a complete Python solution.
		
### Weekly review: ars pioneers
Students take on the role of space pioneers designing the first human settlement on Mars. They write a mission brief, identify vital inputs and outputs (oxygen, water, energy, food), and break the challenge into subproblems like life support, transport, and communication. By mapping data flow and assembling a Python pipeline, they create a structured plan that transforms survival on Mars into a working simulation.

### Final Assessment
