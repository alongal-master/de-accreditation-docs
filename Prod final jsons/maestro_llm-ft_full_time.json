{
  "title": "llm-ft",
  "description": "",
  "modifiedAt": "",
  "createdAt": "2026-01-12",
  "isPublished": false,
  "trackType": "Programming",
  "version": 1,
  "terms": [
    {
      "courses": [
        {
          "title": "llm-ft",
          "description": "",
          "displayId": "",
          "credits": 0,
          "units": [
            {
              "title": "Foundations of LLM Use",
              "lessons": [
                {
                  "title": "AI vs Generative AI",
                  "masteryOutcomes": [
                    "Distinguish AI, Generative AI, NLP, and LLMs using concrete examples",
                    "Identify tasks suited for generative models vs traditional software",
                    "Use correct terminology when describing GenAI systems"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "From ML to LLMs",
                  "masteryOutcomes": [
                    "Describe the progression from rule-based systems ‚Üí machine learning ‚Üí deep learning ‚Üí LLMs",
                    "Explain at a high level why neural networks enabled modern language models",
                    "Identify what changed with transformers compared to earlier approaches"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "What Makes an LLM",
                  "masteryOutcomes": [
                    "Define a Large Language Model in practical terms",
                    "Explain the difference between training and inference at a high level",
                    "Describe what information an LLM can and cannot use at runtime"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Tokens, Context, and Prediction",
                  "masteryOutcomes": [
                    "Define tokens, tokenization, and context window",
                    "Explain next-token prediction as the core LLM mechanism",
                    "Connect context limits and tokenization to model behavior and limitations"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: AI vs Generative AI",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Distinguish between AI, Generative AI, NLP, and LLMs and correctly match each to concrete real-world examples.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: From Rules to LLMs",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Describe the progression from rule-based systems to machine learning, deep learning, and LLMs and identify what changed at each stage.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: What Makes an LLM",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Explain in your own words what an LLM is, and distinguish training vs inference and what information is (and is not) available at runtime.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Tokens and Context Scenarios",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Identify tokens, tokenization, context windows, and next-token prediction behavior in practical scenarios and reason about their limitations.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Token counter helper",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Apply the concepts of tokens, tokenization, and context windows by designing a simple utility (in pseudocode or code) that estimates token usage for user text in a productivity or note-taking scenario. Output: A small script or detailed pseudocode that takes a piece of text and returns an approximate token count and remaining context capacity.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Common Models in Practice",
                  "masteryOutcomes": [
                    "Identify widely used LLM products (e.g. ChatGPT, Gemini, Claude, Copilot)",
                    "Distinguish model, product, and interface",
                    "Match common models to typical tasks (chatting, coding help, summarization, analysis)"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "How We Use LLMs",
                  "masteryOutcomes": [
                    "Identify common interfaces to LLMs (chat websites vs APIs)",
                    "Compare interactive chat usage with programmatic API usage",
                    "Explain how product design shapes model interaction"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Stateless by Default",
                  "masteryOutcomes": [
                    "Define statelessness in the context of LLMs",
                    "Explain why LLMs do not remember past interactions by default",
                    "Describe how conversation history is simulated using context"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Determinism and Reproducibility",
                  "masteryOutcomes": [
                    "Explain why LLM outputs are not fully deterministic",
                    "Identify factors that affect reproducibility (prompt, parameters, context)",
                    "Describe scenarios where reproducibility is critical"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Models, Products, and Interfaces",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Differentiate between ‚Äúmodel,‚Äù ‚Äúproduct,‚Äù and ‚Äúinterface‚Äù by categorizing real-world GenAI tools and their typical use cases.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Chat vs API usage",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Compare interactive chat usage with programmatic API usage and identify which interface is better suited for different application scenarios.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Stateless Conversations",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Explain statelessness in LLMs and describe how conversation history is simulated using context windows.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Conversation history packer",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Design a simple algorithm (pseudocode or code) that builds a conversation payload under a fixed token limit to send to an LLM API. Output: A script or pseudocode that takes a list of past messages and a token budget and returns the subset of messages to include in the next API call.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Determinism and Reproducibility",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Identify why LLM outputs are not fully deterministic and reason about when reproducibility is critical in real-world systems.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "What LLMs Are Bad At",
                  "masteryOutcomes": [
                    "Identify task types LLMs perform poorly on",
                    "Explain why LLMs struggle with correctness guarantees",
                    "Recognize failure patterns unrelated to prompt quality"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "When Not to Use an LLM",
                  "masteryOutcomes": [
                    "Identify scenarios where LLMs add unnecessary risk or cost",
                    "Compare LLM-based solutions to deterministic code",
                    "Justify decisions to avoid GenAI in system design"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Prompts as Interfaces",
                  "masteryOutcomes": [
                    "Define a prompt as an interface between humans and LLMs",
                    "Explain how ambiguity affects model behavior",
                    "Identify why prompts must be designed, not improvised"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Prompt Anatomy",
                  "masteryOutcomes": [
                    "Break a prompt into role, instructions, context, and output",
                    "Identify missing or conflicting prompt components",
                    "Refactor poorly structured prompts into clearer ones"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: LLM Weaknesses in Practice",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Recognize common failure patterns where LLMs perform poorly and separate these from issues caused by bad prompting.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: When Not to Use LLMs",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Decide when a deterministic solution is preferable to an LLM-based approach by evaluating risk, cost, and reliability requirements.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Tool chooser assistant",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Apply decision criteria to design a simple decision flow (pseudocode or flowchart) that suggests ‚ÄúLLM vs traditional code‚Äù for a given task description. Output: A small rules-based script or flowchart that takes a task description and outputs a recommendation plus a short rationale.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Prompt as Interface",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Analyze prompts as interfaces by identifying ambiguity, missing information, and unclear goals in given examples.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Prompt anatomy fixer",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Break prompts into role, instructions, context, and output components and refactor poorly structured prompts into clear RTCO-style versions. Output: A rewritten set of prompts where each original prompt is transformed into a structured version with explicit role, task, context, and output sections.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "RTCO Framework",
                  "masteryOutcomes": [
                    "Define Role, Task, Context, Output precisely",
                    "Apply RTCO to structure prompts",
                    "Evaluate prompts using RTCO as a checklist"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Writing Clear Tasks",
                  "masteryOutcomes": [
                    "Write task instructions that are specific and testable",
                    "Identify vague verbs and unclear goals",
                    "Rewrite tasks to reduce ambiguity"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Defining Outputs",
                  "masteryOutcomes": [
                    "Specify output format and constraints explicitly",
                    "Define what counts as valid vs invalid output",
                    "Reduce model confusion through output definition"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Zero-shot and Few-shot Prompting",
                  "masteryOutcomes": [
                    "Define zero-shot prompting and few-shot prompting",
                    "Select examples that guide model behavior",
                    "Compare zero-shot and few-shot outputs"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: RTCO checklist builder",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Apply the RTCO framework by creating a reusable checklist and using it to evaluate and improve sample prompts in an education or content-creation setting. Output: A concise RTCO checklist plus before/after versions of at least two prompts that show improvements based on the checklist.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Task clarity workshop",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Practice writing specific, testable task instructions by rewriting vague prompts into precise ones with measurable success criteria. Output: A set of paired prompts where each vague task description is rewritten into a clear, unambiguous instruction block.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Output spec templates",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Define explicit output formats and constraints by designing small ‚Äúoutput specification‚Äù templates for different application domains (e.g., budgeting, habit tracking, quizzes). Output: A collection of output specification snippets (e.g., JSON schemas, bullet formats, tables) that can be plugged into prompts to constrain model responses.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Zero-shot vs few-shot comparison - Part 1",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Explore zero-shot prompting by designing prompts for a single task (e.g., generating quiz questions or budgeting tips) without examples and evaluating the outputs. Output: A set of zero-shot prompts and collected model responses, annotated with notes about strengths, weaknesses, and observed behavior.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Zero-shot vs few-shot comparison - Part 2",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Apply few-shot prompting to the same task and compare the quality and consistency of outputs against the zero-shot attempts. Output: A set of few-shot prompts with embedded examples, corresponding model outputs, and a brief written comparison highlighting differences from the zero-shot results.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Prep Lesson",
                  "masteryOutcomes": [
                    "Prep lesson for the weekly review"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                }
              ]
            },
            {
              "title": "Using GenAI in Code",
              "lessons": [
                {
                  "title": "First API Call",
                  "masteryOutcomes": [
                    "Structure a basic LLM API request",
                    "Send input and receive a response",
                    "Inspect raw model outputs"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Message Roles Explained",
                  "masteryOutcomes": [
                    "Define system and user messages",
                    "Explain how message roles affect behavior",
                    "Identify misuse of message roles"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "System Messages in Practice",
                  "masteryOutcomes": [
                    "Write system messages defining role and behavior",
                    "Create reusable system prompts",
                    "Separate behavior rules from task logic"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "User Messages in Practice",
                  "masteryOutcomes": [
                    "Write user messages containing task and context",
                    "Inject dynamic input safely",
                    "Combine system and user messages effectively"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: First API call playground",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Practice sending a basic LLM API request, inspecting the raw response, and identifying key fields in the result. Output: A simple script that sends a message to the model and prints the full raw response in a readable format.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Role-based movie assistant",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Experiment with different system and user message combinations to see how roles change a ‚Äúmovie recommender‚Äù assistant‚Äôs behavior. Output: A script that sends several conversations with varied system/user roles and prints side-by-side responses for comparison.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Reusable system prompts notebook",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Create and reuse multiple system prompts that define distinct assistant personas for a content-creation scenario. Output: A script or notebook that defines several system messages (e.g., ‚Äústrict editor‚Äù, ‚Äúfriendly coach‚Äù) and demonstrates their effect on the same user request.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Context-rich user messages",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Practice writing user messages that clearly separate task instructions from dynamic input for a personal productivity helper. Output: A script that constructs a user message from static instructions plus runtime task data and sends it to the model.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Message roles and misuse",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Strengthen conceptual understanding by classifying examples of system/user messages, spotting misuses, and rewriting them correctly.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Temperature and Output Control",
                  "masteryOutcomes": [
                    "Define temperature as a behavior control parameter",
                    "Explain how temperature affects randomness",
                    "Choose temperature settings for different tasks"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Structured Outputs",
                  "masteryOutcomes": [
                    "Define structured outputs and schemas",
                    "Instruct models to return valid JSON",
                    "Identify common structured-output failures"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Parsing and Validation",
                  "masteryOutcomes": [
                    "Parse structured responses in Python",
                    "Detect invalid or malformed outputs",
                    "Decide when to retry or fail gracefully"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Prompt Templates in Code",
                  "masteryOutcomes": [
                    "Store prompt templates as variables or functions",
                    "Inject runtime data into templates",
                    "Maintain readability and reuse"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Temperature tuning story generator",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Explore how different temperature values affect creativity and consistency in a short ‚Äúdaily habit coach‚Äù story generator. Output: A script that calls the model multiple times with varying temperatures and prints the generated stories for comparison.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: JSON habit tracker schema",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Design a JSON schema for a simple habit-tracking summary and instruct the model to respond strictly in that format. Output: A script that sends a prompt with a JSON schema and prints the model‚Äôs structured summary of a user‚Äôs habits.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Parsing and validating responses",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Implement Python code that parses JSON responses from the model, validates required fields, and handles malformed outputs gracefully. Output: A script that calls the model, attempts to parse its JSON, retries or logs errors when invalid, and prints a cleaned result.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Prompt templates for budgeting helper",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Build reusable prompt templates in code that inject runtime financial data into a structured ‚Äúbudget advice‚Äù prompt. Output: A script with one or more template functions that accept budget inputs and send formatted prompts to the model.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Structured quiz generator",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Combine temperature control, JSON schemas, and templates to generate a small multiple-choice quiz about any topic in a fixed structure. Output: A script that produces a JSON object containing a set of quiz questions, options, and correct answers.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Token Usage and Cost",
                  "masteryOutcomes": [
                    "Explain token-based pricing models",
                    "Estimate cost from prompt and response size",
                    "Identify high-cost prompt patterns"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Reducing Cost and Latency",
                  "masteryOutcomes": [
                    "Reduce prompt length without losing clarity",
                    "Avoid unnecessary model calls",
                    "Balance cost, latency, and accuracy"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "From Prompts to Systems",
                  "masteryOutcomes": [
                    "Distinguish prompts from GenAI systems",
                    "Identify system components beyond a single call",
                    "Explain why systems fail differently than prompts"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Single-Step vs Multi-Step Flows",
                  "masteryOutcomes": [
                    "Compare single-step and multi-step designs",
                    "Identify tasks that require decomposition",
                    "Explain complexity vs reliability tradeoffs"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Token usage estimation",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Practice estimating token counts and costs for different prompt/response sizes and identifying high-cost patterns on paper.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Prompt slimming for FAQ assistant",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Refactor an overly long FAQ-style prompt into a shorter, cheaper version while preserving clarity and intent. Output: A side-by-side text artifact (or notebook cells) showing original vs optimized prompts and notes on expected cost reduction.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Cost-aware batch processing",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Design and code a simple batch text-processing script (e.g., summarizing articles) that estimates and logs token usage and cost. Output: A script that processes multiple inputs, calls the model efficiently, and prints total estimated tokens and cost.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: From prompts to systems",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Analyze several example GenAI applications to distinguish single prompts from full systems and identify likely failure points.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Single-step vs multi-step planner",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Compare single-step and decomposed multi-step flows for a ‚Äústudy plan generator‚Äù and reason about complexity vs reliability. Output: A script or notebook that runs both designs on the same inputs and prints their outputs for qualitative comparison.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Designing Prompt Pipelines",
                  "masteryOutcomes": [
                    "Design simple multi-step prompt pipelines",
                    "Define inputs and outputs between steps",
                    "Identify failure points in pipelines"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "What Is an Agent",
                  "masteryOutcomes": [
                    "Define an agent using role and decision logic",
                    "Distinguish agents from prompt chains",
                    "Identify agent responsibilities"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Agent Control Flow",
                  "masteryOutcomes": [
                    "Define decision rules for agents",
                    "Explain how agents choose next actions",
                    "Prevent unnecessary or repeated steps"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Tools and Tool Calling",
                  "masteryOutcomes": [
                    "Define tools as external functions",
                    "Design simple tool interfaces",
                    "Decide when an agent should call a tool"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Simple study-plan pipeline - Part 1",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Design and implement a two-step prompt pipeline where one step structures user goals and the next produces a study plan. Output: A script that runs sequential model calls, passing structured output from step 1 into step 2 to generate a plan.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Simple study-plan pipeline - Part 2",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Extend the pipeline with basic error checking and fallback behavior when earlier steps fail or return incomplete data. Output: A script that detects missing or malformed intermediate data and either repairs or re-queries before producing the final plan.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "üìö Theory Practice Lesson: Agent vs pipeline identification",
                  "masteryOutcomes": [],
                  "teachingInstructions": "Create a challenge-based lesson that is grounded in the material covered in the **current unit until this lesson, where the student demonstrates the knowledge they have learned in a fun and engaging way. Avoid coding in this lesson.\nThe lesson should include between eight and ten interactive and dynamic rounds between the student and the Maestro. \nThe challenge may include different types of questions or learning experiences, such as varied question formats, interactive tasks, MCQ, identification or matching questions, etc.\nYou are free to choose any structure or format that best supports an engaging challenge experience.\nDuring the challenge itself, there is no need to provide feedback or corrections, the focus should remain entirely on the challenge experience.\nAfter all challenge rounds are completed, provide a short summary that offers encouraging feedback, highlights areas for professional improvement and refinement, and points out the student's strengths as demonstrated through their responses during the challenge.\nEnsure the lesson remains aligned with the topics that were taught and is appropriate for the student's level. Don't code in this lesson.\nLesson goals: Differentiate between prompt pipelines and agents by classifying scenarios and assigning clear agent responsibilities.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Agent decision rules for travel helper",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Define and encode simple decision logic for a travel-planning agent that chooses its next action based on user input and state. Output: A script that simulates an agent loop (without real tools) and prints which action it decides to take at each step.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "‚öô Practice Lesson: Tool-calling weather and budget assistant",
                  "masteryOutcomes": [],
                  "teachingInstructions": "This is a coding challenge lesson. In this lesson, do not introduce new topics; it is about solving an exercise using previously learned concepts only.\nGuide the student step by step toward the solution without writing the full answer or final code for them.\nBreak the problem into small, manageable steps and ask the student to implement each step before moving on.\nWhen the student is stuck, give progressive hints instead of solutions.\nYou may provide example inputs/outputs, edge cases, and clarification to help the student reason about correctness.\nReview the student's work by pointing out what's correct and what needs improvement, then suggest the next step.\nExercise theme is to be chosen based on the lesson title.\nExercise goals and desired output: Design simple tool interfaces and implement an agent that decides when to call a ‚Äúweather‚Äù or ‚Äúbudget‚Äù tool vs replying directly. Output: A script that mocks external tools, lets the model choose tool calls, and prints the full interaction trace.",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                },
                {
                  "title": "Prep Lesson",
                  "masteryOutcomes": [
                    "Prep lesson for the weekly review"
                  ],
                  "teachingInstructions": "",
                  "requiredPlugins": [
                    "code-editor"
                  ]
                }
              ]
            }
          ],
          "label": "",
          "teachingInstructions": "",
          "durationInWeeks": 2,
          "isPublished": false
        }
      ]
    }
  ]
}